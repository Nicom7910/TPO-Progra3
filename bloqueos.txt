1. Simulación de Bloqueos y Conexiones Alternativas 
Un usuario bloquea a otro, rompiendo una conexión en la red. El sistema debe ser 
capaz de determinar si el grafo de amigos sigue siendo completamente conexo. Si 
no lo es, ¿cómo se podría encontrar un conjunto mínimo de nuevas conexiones 
para restablecer la conectividad total? 
Desafío: Piensa en cómo se puede modelar el problema como una búsqueda 
exhaustiva de combinaciones de conexiones, evaluando el impacto de cada 
adición o eliminación. 


OPCIONAL 1 — Simulación de Bloqueos y Conexiones Alternativas
(Informe: Modelaje + Estrategia + Justificación)

1) Modelaje del problema
La red social universitaria se modela como un grafo no dirigido y ponderado:
  G = (V, E)
donde:
- V es el conjunto de usuarios (cada usuario es un nodo).
- E es el conjunto de amistades (cada amistad es una arista no dirigida).
- Cada arista e = (u, v) tiene un costo “costo”, leído desde amistades.json mediante las claves:
    u: extremo 1 de la amistad
    v: extremo 2 de la amistad
    costo: peso asociado a esa conexión

Bloqueo:
Un “bloqueo” entre dos usuarios se modela como la eliminación de una arista:
  (a, b) ∈ E  →  E' = E \ {(a, b)}
y se analiza el grafo resultante:
  G' = (V, E')

Objetivo del opcional:
a) Determinar si G' sigue siendo completamente conexo (existe un camino entre cualquier par de usuarios).
b) Si no es conexo, proponer un conjunto mínimo de nuevas conexiones (aristas nuevas) para restablecer la conectividad total.

En este TP, “mínimo” se interpreta como:
- mínima cantidad de aristas nuevas necesarias para volver a hacer conexo el grafo (no se optimiza el costo total de las nuevas conexiones porque no existe una lista explícita de conexiones potenciales con sus costos).

2) Estrategia para solucionarlo
La estrategia se divide en tres etapas:

Etapa 1 — Aplicar el bloqueo
- Se carga el conjunto de aristas E desde amistades.json.
- Se elimina la arista (a, b) (considerando que el grafo es no dirigido, se elimina tanto (a, b) como (b, a) si apareciera).

Etapa 2 — Determinar conectividad usando Kruskal (Union-Find)
- Se utiliza la estructura Disjoint Set Union (DSU / Union-Find), base del algoritmo de Kruskal.
- Se procesa cada arista de E' aplicando operaciones union(u, v).
- Al finalizar, los conjuntos disjuntos representan las componentes conexas del grafo.
  - Si queda 1 sola componente → el grafo es conexo.
  - Si quedan k > 1 componentes → el grafo NO es conexo.

Etapa 3 — Proponer el conjunto mínimo de nuevas conexiones (k−1)
- Si el grafo queda dividido en k componentes, el mínimo número de aristas necesarias para conectarlas es:
    k − 1
  (cada arista nueva puede reducir como máximo en 1 la cantidad de componentes).
- Para construir esas k−1 aristas:
  1) Se elige un “candidato” por componente.
  2) Se conectan las componentes en cadena uniendo candidatos consecutivos:
       (cand(C1), cand(C2)), (cand(C2), cand(C3)), ..., (cand(C(k−1)), cand(Ck))

Criterio de selección del candidato por componente (pedido por la profesora)
Se define un criterio coherente con el uso de costos del ejercicio de conectividad (ARM/MST):
- Para cada componente, se elige como candidato un nodo asociado a la arista de menor costo dentro del subárbol/bosque que representa esa componente tras Kruskal.
- Si una componente queda aislada sin aristas (nodo suelto), se aplica un “fallback” determinístico:
  tomar el nodo de menor id dentro de la componente.

Este criterio es consistente con la lógica greedy de Kruskal: priorizar conexiones más “baratas” (menor costo) para representar cada subcomponente con un nodo “relevante” según el costo de sus vínculos.

3) Justificación de los algoritmos utilizados
¿Por qué Kruskal / Union-Find para conectividad?
- Kruskal construye un Árbol de Recubrimiento Mínimo (ARM) si el grafo es conexo.
- Si el grafo NO es conexo, Kruskal no puede obtener N−1 aristas; en su lugar produce un bosque (un árbol por componente).
- Gracias a Union-Find, detectar componentes es directo y eficiente:
  - union(u, v) fusiona conjuntos si u y v están en distintas componentes.
  - find(x) permite identificar a qué componente pertenece x.
- Esto permite:
  1) saber si el grafo es conexo (queda 1 conjunto),
  2) obtener cuántas componentes quedan (k),
  3) preparar la reconstrucción mínima (k−1 conexiones).

¿Por qué k−1 conexiones nuevas es mínimo?
- Con k componentes desconectadas, para conectarlas todas se necesita al menos k−1 aristas:
  cada arista nueva solo puede unir dos componentes y reducir el número de componentes en 1.
- Con k−1 uniones entre componentes distintas se garantiza que el grafo final sea conexo.

Análisis de complejidad (resumen)
- Union-Find sobre todas las aristas: ~ O(E α(V)) (casi lineal).
- Construcción de componentes y elección de candidatos: O(V + E).
- Construcción de conexiones nuevas: O(k).
En conjunto: O(V + E) en la práctica, con muy buen desempeño para grafos medianos/grandes.

Nota sobre variantes no implementadas
El enunciado sugiere una búsqueda exhaustiva de combinaciones de nuevas conexiones. Esa estrategia (backtracking/bruteforce) crece combinatoriamente y no escala. Por eficiencia y coherencia con el ejercicio de conectividad, se implementa una solución basada en componentes + reconexión mínima.

Fin del documento.
